# 实施计划：消息队列触发器

## 文档联动

- requirements: `.kiro/specs/triggers-queue/requirements.md`
- design: `.kiro/specs/triggers-queue/design.md`
- tasks: `.kiro/specs/triggers-queue/tasks.md`
- status source: `.kiro/specs/SPEC_TASKS_SCAN.md`


## 概述

本实施计划将消息队列触发器系统的设计转换为可执行的开发任务。系统采用 Python 实现，使用适配器模式支持多种消息队列（Kafka、RabbitMQ、SQS），提供统一的队列接入层、消息解析与路由、幂等性保证、重试机制和治理集成。

实施将按照从核心功能到高级特性的顺序进行，每个阶段都包含相应的测试任务。

## 任务

- [x] 1. 设置项目结构和核心类型定义
  - 创建项目目录结构（owlclaw/triggers/queue/, owlclaw/integrations/queue_adapters/）
  - 定义核心数据类（RawMessage, MessageEnvelope, QueueTriggerConfig）
  - 定义队列适配器协议接口（QueueAdapter Protocol）
  - 定义消息解析器基类（MessageParser ABC）
  - 配置 Python 类型注解和 mypy
  - 设置测试框架（pytest）和属性测试库（hypothesis）
  - _需求：所有需求的基础_

- [x] 2. 实现消息解析器
  - [x] 2.1 实现 MessageParser 基类和具体解析器
    - 实现 JSONParser（JSON 消息解析）
    - 实现 TextParser（文本消息解析）
    - 实现 BinaryParser（二进制消息解析）
    - 实现 ParseError 异常类
    - _需求：3.3_
  
  - [x]* 2.2 为消息解析编写属性测试
    - **属性 3：多格式消息解析**
    - **验证需求：3.3**
  
  - [x]* 2.3 为解析失败编写单元测试
    - 测试无效 JSON 格式
    - 测试编码错误
    - 测试空消息体
    - _需求：3.4_

- [x] 3. 实现 MessageEnvelope 和消息封装
  - [x] 3.1 实现 MessageEnvelope 数据类
    - 定义所有必需字段（message_id、payload、headers、received_at、source）
    - 定义可选字段（dedup_key、event_name、tenant_id）
    - 实现 from_raw_message 类方法
    - _需求：3.1, 3.2_
  
  - [x]* 3.2 为消息封装编写属性测试
    - **属性 2：消息封装完整性**
    - **验证需求：3.1, 3.2**
  
  - [x]* 3.3 为消息封装编写单元测试
    - 测试字段映射正确性
    - 测试可选字段处理
    - 测试时间戳格式
    - _需求：3.1, 3.2_

- [x] 4. 实现 QueueAdapter 接口和 MockQueueAdapter
  - [x] 4.1 定义 QueueAdapter Protocol
    - 定义 connect、consume、ack、nack、send_to_dlq、close、health_check 方法签名
    - 添加完整的类型注解和文档字符串
    - _需求：1.1, 1.2_
  
  - [x] 4.2 实现 MockQueueAdapter
    - 实现所有 QueueAdapter 方法
    - 实现内存队列（使用 deque）
    - 实现测试辅助方法（enqueue、get_acked、get_nacked、get_dlq）
    - _需求：10.1, 10.4_
  
  - [x]* 4.3 为 MockQueueAdapter 编写单元测试
    - 测试消息入队和出队
    - 测试 ack/nack 记录
    - 测试死信队列
    - 测试健康检查
    - _需求：10.1_

- [x] 5. 检查点 - 确保基础组件测试通过
  - 确保所有测试通过，如有问题请询问用户。


- [x] 6. 实现 IdempotencyStore
  - [x] 6.1 定义 IdempotencyStore 抽象基类
    - 定义 exists、set、get 方法签名
    - 添加类型注解和文档字符串
    - _需求：6.1_
  
  - [x] 6.2 实现 RedisIdempotencyStore
    - 实现基于 Redis 的幂等性存储
    - 实现 TTL 过期机制
    - 实现键前缀（idempotency:）
    - _需求：6.1, 6.5_
  
  - [x] 6.3 实现 MockIdempotencyStore
    - 实现基于内存字典的 Mock 存储
    - 实现 TTL 模拟（使用时间戳）
    - _需求：10.1_
  
  - [x]* 6.4 为幂等性存储编写属性测试
    - **属性 15：幂等性保证**
    - **属性 16：幂等性窗口期**
    - **验证需求：6.1, 6.2, 6.3, 6.5**
  
  - [x]* 6.5 为幂等性存储编写单元测试
    - 测试键存在性检查
    - 测试 TTL 过期
    - 测试并发访问
    - _需求：6.1, 6.5_

- [x] 7. 实现 QueueTrigger 核心类
  - [x] 7.1 实现 QueueTrigger 初始化和配置
    - 实现 __init__ 方法（接收配置和依赖）
    - 实现 _create_parser 方法（根据配置创建解析器）
    - 实现配置验证
    - _需求：2.1_
  
  - [x] 7.2 实现生命周期管理方法
    - 实现 start 方法（启动并发消费任务）
    - 实现 stop 方法（优雅关闭）
    - 实现 pause 方法（暂停消费）
    - 实现 resume 方法（恢复消费）
    - 实现 health_check 方法（健康检查）
    - _需求：2.2, 2.3, 2.4_
  
  - [x]* 7.3 为生命周期管理编写属性测试
    - **属性 6：生命周期状态转换**
    - **属性 22：健康检查准确性**
    - **属性 24：优雅关闭**
    - **验证需求：2.2, 2.3, 2.4**
  
  - [x]* 7.4 为生命周期管理编写单元测试
    - 测试启动和停止
    - 测试暂停和恢复
    - 测试健康检查状态
    - 测试优雅关闭超时
    - _需求：2.2, 2.3, 2.4_

- [x] 8. 实现消息消费循环
  - [x] 8.1 实现 _consume_loop 方法
    - 实现异步消息消费循环
    - 实现错误捕获和继续处理
    - 实现工作线程日志
    - _需求：2.5_
  
  - [x] 8.2 实现 _process_message 方法（基础版本）
    - 实现消息解析（调用 MessageEnvelope.from_raw_message）
    - 实现解析失败处理（发送到死信队列）
    - 实现 trace_id 生成
    - _需求：3.1, 3.4_
  
  - [x]* 8.3 为消息消费编写属性测试
    - **属性 4：解析失败路由到死信**
    - **属性 7：错误恢复与继续处理**
    - **验证需求：2.5, 3.4**
  
  - [x]* 8.4 为消息消费编写单元测试
    - 测试并发消费
    - 测试消费循环异常处理
    - 测试工作线程停止
    - _需求：2.1, 2.5_

- [ ] 9. 检查点 - 确保核心消费流程测试通过
  - 确保所有测试通过，如有问题请询问用户。

- [x] 10. 实现幂等性检查
  - [x] 10.1 在 _process_message 中添加幂等性检查
    - 实现 dedup_key 提取（优先使用 envelope.dedup_key，否则使用 message_id）
    - 实现幂等性存储查询
    - 实现重复消息跳过和 ack
    - 实现去重计数器
    - _需求：6.1, 6.2, 6.3, 6.4_
  
  - [x] 10.2 在 _process_message 中添加幂等性记录
    - 实现成功处理后记录幂等性键
    - 实现 TTL 配置应用
    - _需求：6.1, 6.5_
  
  - [x]* 10.3 为幂等性检查编写属性测试
    - **属性 15：幂等性保证**
    - **属性 17：去重计数准确性**
    - **验证需求：6.1, 6.2, 6.3, 6.4**
  
  - [x]* 10.4 为幂等性检查编写单元测试
    - 测试重复消息跳过
    - 测试幂等性键生成
    - 测试幂等性存储失败降级
    - _需求：6.1, 6.2, 6.3_

- [x] 11. 实现治理层集成
  - [x] 11.1 在 _process_message 中添加治理层校验
    - 实现 governance.check_permission 调用
    - 实现执行上下文构建（source、queue、message_id、tenant_id）
    - 实现治理拒绝处理（_handle_governance_rejection）
    - _需求：7.1, 7.4, 4.5_
  
  - [x] 11.2 实现 _handle_governance_rejection 方法
    - 实现拒绝原因记录到 Ledger
    - 实现根据 ack_policy 处理消息（ack 或 dlq）
    - _需求：4.5, 7.4_
  
  - [x]* 11.3 为治理层集成编写属性测试
    - **属性 10：治理层集成与拒绝处理**
    - **验证需求：4.5, 7.1, 7.4**
  
  - [x]* 11.4 为治理层集成编写单元测试
    - 测试治理层允许执行
    - 测试治理层拒绝执行
    - 测试治理层不可用降级
    - _需求：4.5, 7.1_

- [x] 12. 实现 Agent 触发与重试
  - [x] 12.1 实现 _trigger_agent_with_retry 方法
    - 实现重试循环（max_retries + 1 次尝试）
    - 实现 agent_runtime.trigger_event 调用
    - 实现上下文构建（message、headers、source、message_id、received_at）
    - 实现 focus 和 tenant_id 传递
    - 实现指数退避延迟计算
    - 实现重试日志记录
    - _需求：4.1, 4.2, 4.3, 4.4, 5.2, 5.3, 5.5_
  
  - [x]* 12.2 为 Agent 触发编写属性测试
    - **属性 8：Agent 触发与上下文传递**
    - **属性 9：消息路由正确性**
    - **属性 12：重试机制正确性**
    - **属性 14：重试日志完整性**
    - **验证需求：4.1, 4.2, 4.3, 4.4, 5.2, 5.3, 5.5**
  
  - [x]* 12.3 为 Agent 触发编写单元测试
    - 测试成功触发
    - 测试重试延迟计算
    - 测试重试耗尽
    - 测试上下文传递完整性
    - _需求：4.1, 4.2, 5.3_

- [x] 13. 实现错误处理和 Ack 策略
  - [x] 13.1 实现 _handle_processing_error 方法
    - 实现根据 ack_policy 处理错误（ack、nack、requeue、dlq）
    - 实现错误日志记录
    - _需求：5.1_
  
  - [x] 13.2 在 _process_message 中完善错误处理
    - 实现 ParseError 捕获和死信处理
    - 实现其他异常捕获和策略处理
    - 实现重试耗尽后的死信处理
    - _需求：3.4, 5.1, 5.4_
  
  - [x]* 13.3 为错误处理编写属性测试
    - **属性 11：Ack 策略正确执行**
    - **属性 13：重试耗尽后死信处理**
    - **验证需求：5.1, 5.4**
  
  - [x]* 13.4 为错误处理编写单元测试
    - 测试各种 ack 策略
    - 测试死信队列处理
    - 测试错误日志记录
    - _需求：5.1, 5.4_

- [x] 14. 检查点 - 确保核心处理逻辑测试通过
  - 确保所有测试通过，如有问题请询问用户。


- [x] 15. 实现 Ledger 集成和监控指标
  - [x] 15.1 在 _process_message 中添加 Ledger 记录
    - 实现成功处理后的 Ledger 记录
    - 实现记录字段（trace_id、message_id、queue、event_name、tenant_id、status、duration_ms、agent_run_id）
    - 实现处理时长计算
    - _需求：7.2, 7.3_
  
  - [x] 15.2 实现监控指标记录
    - 实现消费速率指标（Prometheus Counter）
    - 实现失败率指标（Prometheus Counter）
    - 实现重试率指标（Prometheus Counter）
    - 实现处理延迟指标（Prometheus Histogram）
    - 实现去重命中指标（Prometheus Counter）
    - 实现 trace_id 记录到日志
    - _需求：7.3, 8.1, 8.2, 8.3, 8.5_
  
  - [x]* 15.3 为 Ledger 和监控编写属性测试
    - **属性 18：Ledger 审计记录完整性**
    - **属性 19：监控指标记录**
    - **属性 21：日志记录完整性**
    - **验证需求：7.2, 7.3, 8.1, 8.2, 8.3, 8.5**
  
  - [x]* 15.4 为 Ledger 和监控编写单元测试
    - 测试 Ledger 记录完整性
    - 测试指标计数准确性
    - 测试日志包含 trace_id
    - _需求：7.2, 7.3, 8.1, 8.2_

- [x] 16. 实现多租户隔离
  - [x] 16.1 在消息处理中添加租户隔离
    - 实现 tenant_id 提取（从 headers 或 envelope）
    - 实现 tenant_id 传递到 Agent Runtime
    - 实现 tenant_id 传递到 Governance Layer
    - 实现 tenant_id 记录到 Ledger
    - _需求：7.5_
  
  - [x]* 16.2 为多租户隔离编写属性测试
    - **属性 20：多租户隔离**
    - **验证需求：7.5**
  
  - [x]* 16.3 为多租户隔离编写单元测试
    - 测试不同租户消息处理
    - 测试租户 ID 传递
    - 测试租户隔离正确性
    - _需求：7.5_

- [x] 17. 实现配置管理
  - [x] 17.1 实现配置加载和验证
    - 实现 load_queue_trigger_config 函数（从 YAML 加载）
    - 实现 _replace_env_vars 函数（替换环境变量）
    - 实现 validate_config 函数（验证配置合法性）
    - 验证必需字段（queue_name、consumer_group）
    - 验证数值范围（concurrency、max_retries、backoff 参数）
    - 验证枚举值（ack_policy、parser_type）
    - _需求：2.1, 10.1_
  
  - [x]* 17.2 为配置管理编写属性测试
    - **属性 5：配置正确应用**
    - **验证需求：2.1**
  
  - [x]* 17.3 为配置管理编写单元测试
    - 测试有效配置加载
    - 测试无效配置检测
    - 测试环境变量替换
    - 测试配置默认值
    - _需求：2.1, 10.1_

- [ ] 18. 实现具体队列适配器（Kafka）
  - [ ] 18.1 实现 KafkaQueueAdapter
    - 实现基于 aiokafka 的 Kafka 适配器
    - 实现 connect 方法（连接到 Kafka broker）
    - 实现 consume 方法（消费消息流）
    - 实现 ack 方法（提交 offset）
    - 实现 nack 方法（不提交 offset）
    - 实现 send_to_dlq 方法（发送到死信 topic）
    - 实现 close 方法（关闭连接）
    - 实现 health_check 方法（检查连接状态）
    - _需求：1.2, 1.3_
  
  - [ ]* 18.2 为 Kafka 适配器编写属性测试
    - **属性 1：适配器接口一致性**
    - **验证需求：1.2, 1.3**
  
  - [ ]* 18.3 为 Kafka 适配器编写集成测试
    - 测试连接到 Kafka（使用 testcontainers）
    - 测试消息消费
    - 测试 offset 提交
    - 测试死信队列
    - _需求：1.2_

- [ ] 19. 实现依赖缺失错误处理
  - [ ] 19.1 实现适配器依赖检查
    - 实现 Kafka 依赖检查（aiokafka）
    - 实现 RabbitMQ 依赖检查（aio_pika）
    - 实现 SQS 依赖检查（aioboto3）
    - 实现清晰的错误消息（包含安装命令）
    - _需求：1.5_
  
  - [ ]* 19.2 为依赖检查编写单元测试
    - 测试缺少依赖时的错误消息
    - 测试错误消息包含安装命令
    - _需求：1.5_

- [ ] 20. 检查点 - 确保所有核心功能测试通过
  - 确保所有测试通过，如有问题请询问用户。

- [ ] 21. 实现端到端集成测试
  - [ ]* 21.1 编写完整的消息处理流程测试
    - 创建完整的消息处理场景（从接收到 Agent 执行）
    - 验证消息解析
    - 验证幂等性检查
    - 验证治理层校验
    - 验证 Agent 触发
    - 验证 Ledger 记录
    - 验证消息确认
    - _需求：所有功能需求_
  
  - [ ]* 21.2 编写幂等性端到端测试
    - 创建重复消息场景
    - 验证只执行一次
    - 验证去重计数
    - 验证幂等性窗口期
    - _需求：6.1, 6.2, 6.3, 6.5_
  
  - [ ]* 21.3 编写重试机制端到端测试
    - 创建失败重试场景
    - 验证重试次数
    - 验证重试延迟
    - 验证重试耗尽后死信处理
    - _需求：5.2, 5.3, 5.4, 5.5_
  
  - [ ]* 21.4 编写错误场景端到端测试
    - 测试解析失败场景
    - 测试治理拒绝场景
    - 测试 Agent 执行失败场景
    - 验证系统继续正常运行
    - _需求：2.5, 3.4, 4.5_

- [ ] 22. 实现日志安全
  - [ ] 22.1 实现凭证脱敏
    - 实现日志过滤器（脱敏密码、token、API key）
    - 实现配置对象的 __repr__ 方法（隐藏敏感字段）
    - 实现错误消息脱敏
    - _需求：9.2_
  
  - [ ]* 22.2 为日志安全编写属性测试
    - **属性 23：凭证安全性**
    - **验证需求：9.2**
  
  - [ ]* 22.3 为日志安全编写单元测试
    - 测试日志不包含密码
    - 测试日志不包含 token
    - 测试配置对象打印安全
    - _需求：9.2_

- [ ] 23. 创建配置文件示例和文档
  - [ ] 23.1 创建配置文件模板
    - 创建 config/queue_trigger.example.yaml 示例配置
    - 包含 Kafka 配置示例
    - 包含 RabbitMQ 配置示例
    - 包含 SQS 配置示例
    - 包含 Mock 配置示例
    - 添加详细的配置说明注释
    - _需求：2.1, 10.1_
  
  - [ ] 23.2 创建环境变量模板
    - 创建 .env.example 文件
    - 包含队列连接环境变量
    - 包含 Redis 连接环境变量
    - 包含 Agent Runtime 环境变量
    - _需求：9.1_
  
  - [ ] 23.3 编写用户指南
    - 创建 docs/triggers/queue.md 用户指南
    - 包含快速开始指南
    - 包含配置说明
    - 包含适配器选型指南
    - 包含故障排查指南
    - _需求：所有功能需求_

- [ ] 24. 实现 Mock 模式验证脚本
  - [ ] 24.1 创建本地验证脚本
    - 创建 scripts/test_queue_trigger.py 脚本
    - 实现使用 MockQueueAdapter 的完整流程
    - 实现消息发送和验证
    - 实现执行结果检查
    - _需求：10.3, 10.4_
  
  - [ ] 24.2 创建验证步骤文档
    - 创建 docs/triggers/queue_validation.md 文档
    - 包含验证步骤说明
    - 包含预期结果说明
    - 包含故障排查指南
    - _需求：10.4_

- [ ] 25. 最终检查点 - 确保所有测试通过并准备部署
  - 运行所有单元测试
  - 运行所有属性测试
  - 运行所有集成测试
  - 检查测试覆盖率（目标 ≥ 80%）
  - 运行类型检查（mypy）
  - 运行代码格式检查（ruff）
  - 如有问题请询问用户

## 注意事项

- 标记为 `*` 的任务是测试重点标记，不代表可跳过；发布前需完成并通过验收
- 每个任务都引用了具体的需求以确保可追溯性
- 检查点确保增量验证
- 属性测试验证通用正确性属性
- 单元测试验证特定示例和边界情况
- 集成测试验证组件间的交互
- 所有代码使用 Python 3.8+ 和类型注解
- 遵循 PEP 8 代码风格
- 使用 pytest 作为测试框架
- 使用 hypothesis 作为属性测试框架
