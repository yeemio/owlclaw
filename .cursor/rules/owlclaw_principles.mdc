---
description: Core principles — apply when editing any production code to enforce code quality, AI-first decisions, no fake data, logging conventions, and safety rules.
globs:
  - "**/*.py"
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.js"
  - "**/*.md"
  - "**/*.yaml"
  - "**/*.yml"
  - "**/*.toml"
  - "**/*.json"
alwaysApply: false
---
# OwlClaw 核心原则

> **版本**: v1.0.0 (2026-02-10)
> **状态**: 核心规范，必须遵守

---

## 一、语言规范（开源项目）

**代码英文，文档中文。**

| 范围 | 语言 | 说明 |
|------|------|------|
| `owlclaw/**/*.py` — docstring + 行内注释 | **English** | 开源代码面向全球开发者 |
| `owlclaw-mcp/**/*.ts` — JSDoc + 行内注释 | **English** | 同上 |
| `examples/` 中的代码注释 | **English** | 示例是开源的一部分 |
| `tests/` 中的代码注释 | **English** | 测试是开源的一部分 |
| `README.md`, `CONTRIBUTING.md`, `LICENSE` | **English** | 开源门面 |
| `docs/`, `.kiro/`, `.cursor/rules/` | **中文** | 目标用户首先是中文开发者 |

```python
# ✅ correct: English docstring and comments
async def run(self, trigger: str, context: str) -> RunResult:
    """Execute a single Agent Run triggered by the given event."""
    # Assemble system prompt with identity, memory, and knowledge
    prompt = await self._build_prompt(trigger, context)
    ...

# ❌ wrong: Chinese in code
async def run(self, trigger: str, context: str) -> RunResult:
    """执行一次 Agent Run"""
    # 组装 system prompt
    ...
```

---

## 二、AI 决策优先

**Agent 的所有业务决策必须由 LLM function calling 做出，禁止硬编码规则。**

```python
# ✅ 正确：Agent 通过 function calling 自主选择
# LLM 看到可见工具列表后，自己决定调用哪个 capability

# ❌ 严禁：硬编码决策逻辑
if is_trading_time() and volatility > 0.05:
    await check_entry_opportunity()  # 禁止！这应该由 Agent 自己判断
```

**核心哲学**：OwlClaw 不控制 Agent，赋能 Agent。框架提供身份、记忆、知识、工具，Agent 自己决定做什么。

---

## 三、代码质量

### 2.1 类型注解

```python
# ✅ 正确：现代 Python 类型注解（Python >= 3.10）
def filter(self, capabilities: list[Capability], context: RunContext) -> list[Capability]:
    ...

async def remember(self, content: str, tags: list[str] | None = None) -> None:
    ...

# ❌ 错误：旧式类型注解
from typing import List, Optional
def filter(self, capabilities: List[Capability]) -> List[Capability]:
    ...
```

### 2.2 异步优先

OwlClaw 的核心路径（Agent Run、capability 执行、LLM 调用）全部使用 async/await。

```python
# ✅ 正确
async def run(self, trigger: str, context: str) -> RunResult:
    ...

# ❌ 错误：在核心路径上使用同步
def run(self, trigger: str, context: str) -> RunResult:
    ...
```

### 2.3 统一日志

**OwlClaw 使用 Python 标准库 `logging`，不引入第三方日志库。**

可观测性分工：
- **应用日志** → stdlib `logging`（本节规范）
- **LLM 调用追踪** → Langfuse（`integrations/langfuse.py`）
- **分布式追踪** → OpenTelemetry（标准协议）
- **Agent 决策记录** → Ledger（`governance/ledger.py`）

#### 基本模式

每个模块顶部声明 logger，使用 `__name__` 自动获取模块路径：

```python
# ✅ correct: one logger per module
import logging
logger = logging.getLogger(__name__)
```

#### SDK 库不配置 logging

OwlClaw 是 SDK 库（`pip install owlclaw`），**禁止在库代码中配置 logging**（不调用 `logging.basicConfig()`、不添加 handler/formatter）。日志的输出格式、级别、目标由使用方（业务应用）决定。

```python
# ❌ forbidden in library code
logging.basicConfig(level=logging.INFO)
logging.getLogger().addHandler(logging.StreamHandler())

# ✅ correct: only create logger, let the application configure output
logger = logging.getLogger(__name__)
```

#### 日志级别使用规范

| 级别 | 场景 | 示例 |
|------|------|------|
| `DEBUG` | Development-time diagnostics, verbose internal state | `logger.debug("Scanning %s for SKILL.md files", path)` |
| `INFO` | Normal operational milestones, startup/shutdown | `logger.info("Loaded %d Skills from %s", count, path)` |
| `WARNING` | Recoverable issues, degraded behavior, fallback triggered | `logger.warning("Skill '%s' missing frontmatter, skipped", name)` |
| `ERROR` | Operation failed but process continues | `logger.error("Handler '%s' execution failed: %s", name, err)` |
| `EXCEPTION` | Same as ERROR but includes traceback (use in except blocks) | `logger.exception("Unexpected error in capability '%s'", name)` |
| `CRITICAL` | Process cannot continue, fatal condition | Rarely used in SDK |

#### 禁止 print

`print()` 的输出无法被日志系统控制（级别、格式、路由），**严禁在生产代码中使用 `print()` 输出运行信息**。

```python
# ❌ forbidden
print(f"Loaded {count} Skills from {path}")

# ✅ correct
logger.info("Loaded %d Skills from %s", count, path)
```

#### 日志消息格式

使用 `%s` 占位符（lazy formatting），不使用 f-string：

```python
# ✅ correct: lazy formatting, string only built if level is enabled
logger.warning("Skill file %s missing frontmatter", file_path)

# ❌ avoid: f-string always evaluated regardless of log level
logger.warning(f"Skill file {file_path} missing frontmatter")
```

---

## 四、禁止假数据

- 数据获取失败时返回空结果并明确提示错误
- **严禁**返回硬编码备用数据
- **严禁**在测试中使用 mock 数据冒充真实数据

---

## 五、关键操作必须校验

### 4.1 capability 执行后校验

```python
# ✅ 正确：执行后验证结果
result = await capability_handler(session)
if result is None:
    logger.error(f"Capability {name} 返回空结果")
    await ledger.record_failure(name, "empty_result")

# ❌ 错误：只执行不验证
result = await capability_handler(session)
return {"success": True}  # 不知道结果是否正确
```

### 4.2 异常处理

```python
# ❌ 错误：吞掉异常
except Exception as e:
    logger.warning(f"失败: {e}")
    return None

# ✅ 正确：记录完整信息
except Exception as e:
    logger.exception(f"Capability {name} 执行异常")
    raise
```

---

## 六、变更前必须检查

修改任何模块前，先检查影响范围：

```bash
# 修改 Agent 运行时前
rg "from owlclaw.agent" owlclaw/ --glob "*.py"

# 修改治理层前
rg "CapabilityVisibilityFilter\|governance" owlclaw/ --glob "*.py"

# 修改 Hatchet 集成前
rg "hatchet\|integrations.hatchet" owlclaw/ --glob "*.py"
```

---

## 七、禁止行为

| 禁止行为 | 后果 |
|----------|------|
| **代码中留 TODO/FIXME/HACK/XXX** | **返工概率极高，未完成功能记录在 tasks.md 中** |
| **NotImplementedError 占位** | **返工概率极高，用 `...` 声明接口或完整实现** |
| 硬编码 Agent 决策逻辑 | 违背 Agent 自驱动哲学 |
| 在 `_collect_pending()` 中调用外部 API | Heartbeat 应零外部 I/O |
| 在治理层之外执行 capability | 绕过可见性过滤和 Ledger |
| 直接调用 LLM（不经过 litellm） | 绕过模型路由和成本追踪 |
| 直接调用 Hatchet（不经过 integrations/hatchet.py） | 破坏集成隔离 |
| 在 Skills SKILL.md 中硬编码业务逻辑 | Skills 是知识文档，不是代码 |
| 禁止假数据 | 误导 Agent 决策 |
| 吞掉异常不记录 | 问题被隐藏 |
| 边做边想，没有完整方案 | 反复修改，架构腐化 |

---

**执行承诺**：代码英文/文档中文 · AI 决策优先 · 关键操作必校验 · 变更前必检查 · 先规划后执行
