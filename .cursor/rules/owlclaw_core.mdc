---
description: Global workspace rules — OwlClaw project core process, principles, and pointers to domain rules.
globs:
  - "*"
alwaysApply: true
---
# OwlClaw 工作指导总纲

> **版本**: v1.0.0 (2026-02-10)
> **项目**: OwlClaw — Agent base for business applications
> **许可证**: MIT

---

## 〇、项目定位

OwlClaw 是一个**面向成熟业务应用的 Agent 基础设施**，核心理念：

> **不要控制 Agent，赋能 Agent。**
> **不要重造轮子，组合轮子。**

- **产品愿景**：Markdown 即 AI 能力——业务开发者用 SKILL.md 描述业务接口，OwlClaw 的 Agent 自动理解并使用，无需 AI 开发团队
- **自建**：Agent 运行时（身份/记忆/知识/决策）、能力注册与 Skills 挂载、治理层（可见性过滤/Ledger/预算）、事件触发器统一层、Skills 生态（OwlHub）
- **集成**：Hatchet MIT（持久执行）、litellm（LLM）、Langfuse（可观测）、Agent Skills 规范（知识文档）
- **生态定位**：编排框架（LangChain）给 Agent 手和脚，OwlClaw 给 Agent 大脑和心跳——生态位互补，不是竞争
- **架构文档**：`docs/ARCHITECTURE_ANALYSIS.md`（v4.0，唯一架构真源）

---

## 一、文档结构

| 文档 | 内容 | 状态 |
|------|------|------|
| **主文档** (本文档) | 核心索引、工作流程 | ✅ |
| **核心原则** | `.cursor/rules/owlclaw_principles.mdc` | ✅ |
| **开发规范** | `.cursor/rules/owlclaw_development.mdc` | ✅ |
| **架构规范** | `.cursor/rules/owlclaw_architecture.mdc` | ✅ |
| **测试规范** | `.cursor/rules/owlclaw_testing.mdc` | ✅ |
| **Spec 标准** | `.cursor/rules/owlclaw_spec_standards.mdc` | ✅ |
| **数据库规范** | `.cursor/rules/owlclaw_database.mdc` | ✅ |
| **数据库架构** | `docs/DATABASE_ARCHITECTURE.md` | ✅ |

---

## 二、AI 必读文档

### 按阅读场景

| 阅读场景 | 文档 | 内容 |
|----------|------|------|
| 每次 | 本文档 | 核心原则与项目定位 |
| 每次 | `docs/ARCHITECTURE_ANALYSIS.md` | 架构设计（唯一真源） |
| 开发 | `.cursor/rules/owlclaw_principles.mdc` | 核心原则（代码质量、AI 决策、禁止行为） |
| 开发 | `.cursor/rules/owlclaw_development.mdc` | 开发规范（流程、Git、Poetry） |
| 架构 | `.cursor/rules/owlclaw_architecture.mdc` | 架构规范（包结构、集成边界） |
| 数据库 | `.cursor/rules/owlclaw_database.mdc` | 数据库编码规范（tenant_id、SQLAlchemy、Alembic、pgvector） |
| 数据库 | `docs/DATABASE_ARCHITECTURE.md` | 数据库架构（唯一真源：部署模式、数据模型、迁移、运维 CLI） |
| 测试 | `.cursor/rules/owlclaw_testing.mdc` | 测试规范（pytest、覆盖率） |
| 写/改 spec | `.cursor/rules/owlclaw_spec_standards.mdc` | Spec 文档标准 |
| 写/改 spec | `.kiro/SPEC_DOCUMENTATION_STANDARD.md` | Spec 三层文档结构详细规范 |

### AI 工作流程

```
1. 接收任务
 ↓
2. 阅读本文档（项目定位与核心原则）
 ↓
3. 根据任务类型阅读相关子文档
 ↓
4. 阅读 docs/ARCHITECTURE_ANALYSIS.md（理解架构决策）
 ↓
5. 检查影响范围（grep 搜索）
 ↓
6. 新功能/重大重构：确认已有 spec（三层齐全）再编码；无 spec 则先补齐
 ↓
7. 阅读相关代码
 ↓
8. 开始编码
```

---

## 三、关键规则速查

| 规则 | 说明 | 详细文档 |
|------|------|---------|
| **禁止 TODO 预留** | 代码中不留 TODO/FIXME，未完成功能记录在 tasks.md | `owlclaw_development.mdc` |
| **包管理用 Poetry** | `poetry add`、`poetry install`、`poetry run` | `owlclaw_development.mdc` |
| **Python >= 3.10** | 类型注解用现代语法 | `owlclaw_development.mdc` |
| **绝对导入** | `from owlclaw.agent.runtime import ...` | `owlclaw_architecture.mdc` |
| **AI 决策优先** | Agent 的决策由 LLM function calling 做出，禁止硬编码规则 | `owlclaw_principles.mdc` |
| **禁止假数据** | 数据获取失败返回空结果，不返回硬编码备用数据 | `owlclaw_principles.mdc` |
| **先规划后执行** | 重构/修改前必须制定完整方案 | `owlclaw_development.mdc` |
| **Spec 文档规范** | 新功能和重大重构必须使用三层文档结构 | `owlclaw_spec_standards.mdc` |
| **Spec 循环** | 触发词「继续」驱动多轮，SPEC_TASKS_SCAN 为单一真源 | 本文档第四节 |
| **代码英文/文档中文** | 代码注释 English，文档中文 | `owlclaw_principles.mdc` |
| **Hatchet 集成隔离** | Hatchet 调用集中在 `owlclaw/integrations/hatchet.py` | `owlclaw_architecture.mdc` |
| **Agent Skills 规范** | 知识文档遵循 Anthropic Agent Skills 规范（SKILL.md） | `owlclaw_architecture.mdc` |
| **治理 = 可见性过滤** | Agent 看到的工具列表是经过治理过滤的子集 | `owlclaw_architecture.mdc` |
| **接入协议语言无关** | 对外暴露的能力描述必须是纯数据（JSON Schema），Python SDK 是语法糖 | `owlclaw_architecture.mdc` |
| **数据库 database 级隔离** | 复用宿主 PG，owlclaw / hatchet 各自独立 database，禁止跨库访问 | `owlclaw_architecture.mdc`、`docs/DATABASE_ARCHITECTURE.md` |
| **编排框架标准接入** | LangChain chain/LangGraph workflow 通过 @handler 注册为 capability，OwlClaw 不依赖任何编排框架 | `ARCHITECTURE_ANALYSIS.md` §4.8 |
| **Skills 生态（OwlHub）** | SKILL.md 遵循 agentskills.io 规范；OwlHub 渐进式架构（GitHub → 静态站点 → 数据库）；CLI 优先；模板降低门槛 | `ARCHITECTURE_ANALYSIS.md` §2.7 + §4.10 |

---

## 四、Spec 循环（触发词：spec循环 / 继续 / 挨个完成 / 全部完成 / 持续推进 / 自主推进）

**Goal**：将 SPEC_TASKS_SCAN 功能清单与各 spec 的 tasks.md 中 `[ ]` 通过实现+验收变为 `[x]`，直至无未勾项或用户叫停。

**持续/自主推进**：用户可通过**反复发送「继续」**实现多轮推进，无需每次重述「spec 循环」。每轮结束时若**未达 Exit**，AI **必须**在回复末尾给出明确提示，例如：「**回复「继续」以执行下一轮 spec 循环。**」触发词包括：`spec循环`、`继续`、`挨个完成`、`全部完成`、`持续推进`、`自主推进`。

**Authority**：`.kiro/specs/SPEC_TASKS_SCAN.md` 功能清单；各 spec 的 `tasks.md`。收口 = task 内全部 `[x]` 且实现+验收通过 → 功能清单对应行打勾。

### Rules

- **验收标准**：仅当实现+验收通过可打勾；不得以 deferred/按需代替；未实现保留 `[ ]` 记 design/backlog。写入 spec 的 task = 必须完成（不做的放 backlog/单独 spec）；功能清单须 ⊇ 各 spec tasks，缺则补。
- **批次控制**：单次循环最多完成 3 个 task（或 1 个复杂 spec）；建议每轮 1～3 项，不必凑满。完成后必须更新文档、检查点，然后评估是否继续。避免单次循环过长导致上下文溢出。
- **失败处理**：验收失败时必须分析原因 → 若设计问题回退到 design.md 修正；若实现问题回滚代码重新实现；若依赖问题标记 blocked 并记录依赖。同一 task 连续失败 3 次自动标记 blocked。
- **持续推进**：SPEC_TASKS_SCAN 或 tasks.md 有 `[ ]` → 必须执行下一可执行项或产出可执行项（拆解/新增 spec）；不得以无可执行、内部依赖未就绪为由停；仅**外部不可控依赖**可写明后收口。
- **占位处理**：剩余均为占位/可选时须产出可执行下一步（拆解子动作 / 新增 spec / 纳入当前批次），不得只写阻塞即停。
- **连续执行**：文档/契约/Task 0 完成后须检查该 spec 下一未勾 task 是否可立即实现，若可则接着做并打勾，直至无可实现或写明依赖。
- **禁止中途汇报**：未达 Exit 前不得输出「本轮收口」「无可执行」并等待用户；若已写「下一执行批次」须取至少一项实现+验收+打勾。
- **多 AI 协作（Worktree 隔离）**：多 AI 协作采用 Git Worktree 物理隔离（详见 `docs/WORKTREE_GUIDE.md`）。每个 AI Agent 在自己的 worktree 中独立工作，无需检查文件是否被其他 Agent 修改，Spec 循环正常推进不跳过任何 task。任务分配见 `.kiro/WORKTREE_ASSIGNMENTS.md`。
- **每轮提交**：每一轮 spec 循环结束后（Doc/Checkpoint 更新完成后），必须对当前变更执行一次 **git commit**，提交信息应包含本轮完成的 task 或批次标识（例如 `spec: cli-db Task N` 或 `spec loop: batch Y`），便于协作与回溯。
- **资源释放（防死机）**：每轮 spec 循环的 **Observe/Verify 步骤**执行测试后，必须确保 Python 子进程已退出：① 优先使用 `poetry run pytest ... --timeout=30` 加超时限制；② 禁止在后台 `&` 启动测试进程后不等待；③ 若使用 `subprocess` 启动进程，必须调用 `.wait()` 或 `with` 上下文管理器确保退出；④ 每批次测试结束后执行 `taskkill /F /IM python.exe /T`（Windows）或 `pkill -f pytest`（WSL）清理残留进程，再进行下一批次。**违反此规则会导致内存耗尽死机。**
- **审校把关**：编码 worktree 的变更需经过审校 worktree（owlclaw-review）的 Review Loop 审核后才能合并到 main。审校 worktree 承担技术经理角色，负责 spec 一致性、代码质量、测试覆盖、架构合规的终审。详见 `.kiro/WORKTREE_ASSIGNMENTS.md` 中审校循环定义。

### Loop

（**轮** = 用户每发一次「继续」触发的一轮循环；跨轮计数依赖 SPEC_TASKS_SCAN 的 Checkpoint）

1. **Sync** — （Worktree 模式）`git merge main` 同步最新代码，确保在最新基线上工作。读取 `.kiro/WORKTREE_ASSIGNMENTS.md` 确认自己的任务分配。
2. **Check** — 功能清单 ⊇ 各 spec tasks；缺则补。取未打勾项与 tasks.md 中 `[ ]`。**Health Check**：读取 Checkpoint 中无进展轮数/连续失败次数；同一 task 连续失败 ≥3 次 → 标记 blocked；单个 spec 连续 >10 轮无进展 → 提示用户介入。
3. **Plan** — 从自己分配的 spec 的未勾项中选择下一批次（建议本批 1～3 个 task 或 1 个复杂 spec），评估依赖关系与优先级。
4. **Do** — 对当前批次的每个 task：
   - **Act（实现）**：编写代码/文档（Worktree 隔离模式下无需冲突检查，各 Agent 在独立 worktree 中工作）
   - **Observe（观察）**：执行测试、检查输出、验证行为
   - **Reflect（反思）**：结果符合预期？需要调整？
   - **Verify（验收）**：通过 → task `[x]` → 功能清单打勾；**失败 → 分析原因 → 回滚/标记 blocked**
   - **若本 spec 仍有未勾且可实现的下一 task，继续执行该 task（回本步）**，不先汇报。
5. **Doc** — 更新 SPEC_TASKS_SCAN。**Checkpoint**：必须在 SPEC_TASKS_SCAN 的检查点表中更新：最后更新时间、当前批次、批次状态、已完成项数、下一待执行项、阻塞项、健康状态。
6. **Commit** — 本轮变更（SPEC_TASKS_SCAN、tasks.md、代码与文档）执行 **git commit**，提交信息简明包含本轮批次或完成项（如 `spec loop: <spec名> Task N` 或 `spec: batch Y`）。变更留在自己的分支上，**等待审校 worktree 的 Review Loop 审核后合并到 main**。
7. **Evaluate** — 本批次是否全部完成？是否遇到阻塞？健康检查是否通过？功能清单 vs tasks.md 一致性检查；仍有 `[ ]` → 回 1。
8. **Schedule** — 仅当本轮可实现项已全勾：定下一执行批次，写 SPEC_TASKS_SCAN。**若当前仅剩占位/可选**：须在本步**产出至少一项可执行工作**（拆解子动作、或新增/补齐 spec），写入「下一执行批次」，然后回 1 或 9。
9. **Run batch** — 若当前排期为可实现：**直接实现+验收+打勾**，回 4/5。若 SPEC_TASKS_SCAN 中已写出「下一执行批次」，**须从该批次取至少一项执行**，不得仅写排期即停。

### Exit（以下情况可停）

1. **用户叫停**：用户明确要求停止
2. **完全完成**：功能清单与所有 tasks.md 均已全部打勾
3. **阶段性完成**：当前批次全部完成，且下一批次在 SPEC_TASKS_SCAN 中**已显式标注**「需用户决策」或「需外部输入」
4. **阻塞状态**：所有剩余未勾项均已明确为外部不可控依赖（且已写明，且无可拆解子动作）
5. **健康检查触发**：检测到循环异常（如同一 task 连续失败 3 次、单个 spec 循环 >10 轮无进展），需要人工介入

**注意**：「无可执行」或「剩余为可选」不是 Exit；若下一执行批次有项，须先执行至少一项再评估。

---

## 五、统筹循环（触发词：统筹 / orchestrate / 主目录推进 / 管理推进）

> **适用范围**：仅主 worktree（`D:\AI\owlclaw\`，branch `main`）的 Cursor / 人工使用。
> **目的**：作为技术经理，一键检查所有 worktree 状态、执行 merge、分配新任务、解锁阻塞项，输出总览报告。

**持续推进**：反复发送「统筹」可多轮驱动。每轮结束若仍有待处理事项，在回复末尾提示「**回复「统筹」执行下一轮。**」

### Orchestrator Loop

```
1. Status  — 运行以下命令获取全局状态：
             git worktree list
             git log --oneline main -3
             git log --oneline main..review-work
             git log --oneline main..codex-work
             git log --oneline main..codex-gpt-work
             读取 .kiro/WORKTREE_ASSIGNMENTS.md 确认各 worktree 当前任务与进度

2. Merge   — 检查 review-work 是否有待合并内容：
             有 → git merge review-work（在主 worktree 执行）

3. Sync    — **main 每次有新 commit 后（无论来自 merge 还是文档更新），必须立即同步所有子 worktree**：
             cd D:\AI\owlclaw-review    && git merge main
             cd D:\AI\owlclaw-codex     && git merge main
             cd D:\AI\owlclaw-codex-gpt && git merge main
             若有冲突 → 就地解决（通常只有 SPEC_TASKS_SCAN.md），取最新进度版本
             ⚠️ 跳过此步会导致编码 worktree 读到旧任务分配，继续执行已完成的旧 spec

4. Assign  — 检查各编码 worktree 是否完成当前 spec：
             完成 → 从 WORKTREE_ASSIGNMENTS.md「下一轮待分配」中选下一个 spec
             更新 WORKTREE_ASSIGNMENTS.md 的分配表和分配历史

5. Unblock — 读取 .kiro/specs/SPEC_TASKS_SCAN.md 的 blocked 项：
             评估是否可人工解锁（补充外部依赖、架构决策、拆解子任务）
             可解锁 → 直接处理或在 SPEC_TASKS_SCAN 中标注解锁方案

6. Commit  — 若本轮有 main 变更（merge 或文档更新）：
             git add -A && git commit -m "chore(orchestrate): <本轮操作摘要>"

7. Report  — 输出状态总览表：
             | Worktree | 分支 | 当前 spec | 进度 | 健康 | 待处理 |
             每行一个 worktree，含 review-work 的审校状态
```

### Exit（以下情况停止）

1. 用户叫停
2. 所有 worktree 均无待处理任务（review-work 无待审内容，编码 worktree 无未完成 spec）
3. 遇到需要人工架构决策的阻塞项（明确标注后停止）

---

## 六、执行承诺

- 代码英文，文档中文（语言规范见 `owlclaw_principles.mdc`）
- AI 决策优先，禁止硬编码业务规则
- 先规划后执行，一次到位
- 包管理统一用 Poetry
- 绝对导入，禁止相对导入
- 测试覆盖关键路径
- Spec 文档规范，新功能必须使用三层文档结构
- 集成组件保持隔离，方便替换
- Spec 循环驱动开发，SPEC_TASKS_SCAN 为单一真源

---

**维护者**: yeemio
**下次审核**: 2026-03-01
